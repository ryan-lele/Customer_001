      
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyber Landscape - Star System V2</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Segoe UI', sans-serif; 
            user-select: none; 
            touch-action: none; 
        }

        #viewport {
            position: absolute;
            top: 0%;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000510; 
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,1); 
            cursor: none; 
        }

        canvas { display: block; }

        #ui-layer {
            position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10;
        }
        .panel {
            background: rgba(0, 5, 10, 0.85);
            backdrop-filter: blur(8px);
            padding: 20px; border-radius: 4px; border: 1px solid rgba(255, 204, 0, 0.5);
            color: #eee; width: 280px; pointer-events: auto;
            box-shadow: 0 0 25px rgba(255, 204, 0, 0.15);
            transition: opacity 0.6s ease, transform 0.6s ease;
            opacity: 1; transform: translateY(0);
            cursor: default; 
        }

        .panel.hidden-ui { opacity: 0; pointer-events: none; transform: translateY(-20px); }

        h1 {
            margin: 0 0 15px 0; font-size: 16px; letter-spacing: 3px; font-weight: 800;
            text-transform: uppercase; color: #ffcc00; 
            text-align: center; border-bottom: 1px solid rgba(255, 204, 0, 0.3); padding-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 204, 0, 0.8);
        }
        .status-text { font-size: 12px; color: #ffeb99; display: block; text-align: center; margin-bottom: 15px; min-height: 1.5em; text-shadow: 0 0 5px rgba(255,200,0,0.5);}
        
        .btn-group { display: flex; flex-direction: column; gap: 10px; }
        
        button, .file-label {
            display: block; width: 100%; box-sizing: border-box;
            padding: 12px; background: rgba(255, 204, 0, 0.05);
            border: 1px solid #ffcc00; color: #ffcc00;
            cursor: pointer; font-size: 12px; transition: 0.3s;
            text-transform: uppercase; letter-spacing: 1px;
            text-align: center; font-weight: bold;
        }
        button:hover, .file-label:hover { 
            background: rgba(255, 204, 0, 0.2); 
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.5); transform: scale(1.02); 
        }
        button:disabled { border-color: #443300; color: #665500; cursor: not-allowed; pointer-events: none; box-shadow: none; transform: none; }
        
        #cam-btn { border-color: #00ffff; color: #00ffff; }
        #cam-btn:hover { background: rgba(0, 255, 255, 0.2); box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }

        input[type="file"] { display: none; }

        .hint { font-size: 10px; color: #887744; margin-top: 15px; text-align: center; line-height: 1.4; }
        .gesture-hint { margin-top:8px; color: #00ffff; font-weight: bold; animation: pulse 2s infinite; }
        
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; text-shadow: 0 0 8px cyan; } 100% { opacity: 0.7; } }

        /* HUD Spectrum */
        #hud-spectrum {
            position: absolute; bottom: 0; right: 20px; width: 320px; height: 100px;
            background: linear-gradient(180deg, transparent 0%, rgba(0, 10, 20, 0.6) 100%);
            border-bottom: 2px solid #ffcc00; pointer-events: none; z-index: 20;
        }
        
        #touch-indicator {
            display: none !important; 
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px; border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; transform: translate(-50%, -50%) scale(0);
            pointer-events: none; transition: transform 0.1s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); z-index: 5;
        }

        #webcam-preview {
            position: absolute; bottom: 0; left: 20px;
            width: 160px; height: 120px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: transparent;
            z-index: 30; opacity: 0; transition: opacity 0.5s;
            transform: scaleX(-1); border-bottom: none; 
            display: none; 
        }
        #webcam-preview.active { opacity: 0.8; }
        .input_video { display: none; }

        .cine-line {
            position: absolute; left: 0; width: 100%; height: 1px;
            background: rgba(255, 204, 0, 0.3); z-index: 50; pointer-events: none;
        }
        #line-top { top: 0; }
        #line-bottom { bottom: 0; }
    </style>
</head>
<body>

    <video class="input_video" id="input-video"></video>

    <div id="viewport">
        <div class="cine-line" id="line-top"></div>
        <canvas id="webcam-preview" style="display=none"></canvas>

        <div id="ui-layer">
            <div class="panel" id="main-panel">
                <h1>Gold Horizon <span style="font-size:0.6em; display:block; color:#fff; margin-top:2px; opacity:0.5;">STARLIGHT EDITION</span></h1>
                <span class="status-text" id="status-text">System Online</span>
                
                <div class="btn-group">
                    <button id="demo-btn">üéµ ÂêØÂä®ÊºîÁ§∫: Cyberpunk City</button>
                    <label for="music-upload" class="file-label">üìÇ Âä†ËΩΩÊú¨Âú∞Èü≥È¢ë</label>
                    <input type="file" id="music-upload" accept="audio/*">
                    
                    <button id="cam-btn">üì∑ ÂºÄÂêØÊâãÂäøÊéßÂà∂</button>
                    
                    <button id="play-btn" disabled>‚ñ∂ Êí≠Êîæ / ÊöÇÂÅú</button>
                    <button id="fs-btn">ÂÖ®Â±èÊ≤âÊµ∏Ê®°Âºè</button>
                </div>

                <div class="hint">
                    <div>‰ΩéÈ¢ëÂº∫ÂåñÂºïÊìé ¬∑ Á∫ØÂáÄÊòüÁ©∫</div>
                    <div class="gesture-hint">‚¨ÖÔ∏è ÊâãÂäøÊÑüÂ∫î / Ëß¶Êéß ‚û°Ô∏è</div>
                </div>
            </div>
        </div>

        <canvas id="hud-spectrum" width="320" height="100"></canvas>
        <div id="touch-indicator"></div>
        <div class="cine-line" id="line-bottom"></div>
    </div>

    <script>
        // ================= ÈÖçÁΩÆÂèÇÊï∞ =================
        const CONFIG = {
            particleCount: 1300000, 
            rangeX: 200,           
            rangeZ: 200,           
            lineCount: 600,        
            colorRiver: new THREE.Color('#3388ff'),
            
            // Êä§ÁúºÊ∑±Ëâ≤Ë∞É
            colorMtBase: new THREE.Color('#001829'), 
            colorMtTop: new THREE.Color('#00ffff'), 
            
            speed: 18.0            
        };

        const viewport = document.getElementById('viewport');

        // ================= 1. Èü≥È¢ëÂàÜÊûêÁ≥ªÁªü =================
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioElement = new Audio();
        audioElement.crossOrigin = "anonymous"; 
        audioElement.loop = true; 
        
        let analyser = null;
        let dataArray = null;
        let source = null;
        let isPlaying = false;
        let uiHiddenMode = false; 

        const DEMO_URL = "https://cdn.pixabay.com/download/audio/2022/03/09/audio_822452586e.mp3?filename=cyberpunk-city-106680.mp3"; 

       function setupAudio() {
            if (source) return;
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 1024;
            analyser.smoothingTimeConstant = 0.6; 
            
            source = audioCtx.createMediaElementSource(audioElement);
            source.connect(analyser);
            analyser.connect(audioCtx.destination); 
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        // Âä®Âäõ‰ø°Âè∑Ôºö‰ΩéÈ¢ë‰∏ªÂØº
        function getBassSignal() {
            if (!analyser || !isPlaying) return 0.1;
            
            let bassSum = 0;
            for (let i = 0; i < 8; i++) {
                bassSum += dataArray[i];
            }
            let bassEnergy = (bassSum / 8) / 255.0; 
            bassEnergy = Math.pow(bassEnergy, 3) * 12.0; 

            let midSum = 0;
            for(let i=10; i<60; i++) midSum += dataArray[i];
            let midEnergy = (midSum / 50) / 255.0;

            return bassEnergy + midEnergy * 1.5;
        }

        const fileInput = document.getElementById('music-upload');
        const playBtn = document.getElementById('play-btn');
        const demoBtn = document.getElementById('demo-btn');
        const statusText = document.getElementById('status-text');
        const mainPanel = document.getElementById('main-panel');

        function handlePlayStart(name) {
            isPlaying = true;
            playBtn.disabled = false;
            playBtn.innerText = "‚è∏ ÊöÇÂÅú";
            statusText.innerText = `Ê≠£Âú®Êí≠Êîæ: ${name}`;
            uiHiddenMode = true;
            setTimeout(() => { if (uiHiddenMode) mainPanel.classList.add('hidden-ui'); }, 2500);
        }

        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const objectUrl = URL.createObjectURL(file);
            audioElement.src = objectUrl;
            setupAudio(); 
            audioElement.play().then(() => handlePlayStart(file.name.substring(0, 15)+'...'))
            .catch(err => { console.error(err); statusText.innerText = "ËØ∑ÊâãÂä®ÁÇπÂáªÊí≠Êîæ"; });
        });

        demoBtn.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            statusText.innerText = "Ê≠£Âú®Êé•ÂÖ•ÁΩëÁªúÊµÅ...";
            demoBtn.disabled = true; demoBtn.style.opacity = "0.5";
            audioElement.src = DEMO_URL;
            setupAudio();
            audioElement.play().then(() => {
                handlePlayStart("Cyberpunk City");
                demoBtn.disabled = false; demoBtn.style.opacity = "1";
            }).catch(err => {
                statusText.innerText = "ÁΩëÁªúÈîôËØØÔºåËØ∑ÈáçËØï";
                demoBtn.disabled = false;
            });
        });

        playBtn.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (isPlaying) {
                audioElement.pause();
                playBtn.innerText = "‚ñ∂ ÁªßÁª≠Êí≠Êîæ";
                statusText.innerText = "Â∑≤ÊöÇÂÅú";
            } else {
                audioElement.play();
                playBtn.innerText = "‚è∏ ÊöÇÂÅú";
                statusText.innerText = "Êí≠Êîæ‰∏≠...";
            }
            isPlaying = !isPlaying;
        });

        document.addEventListener('mousemove', (e) => {
            if (!uiHiddenMode) return; 
            const rect = viewport.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (e.clientY >= rect.top && e.clientY <= rect.bottom) {
                const isHoveringZone = e.clientX < 320 && relY < 400;
                if (isHoveringZone) mainPanel.classList.remove('hidden-ui');
                else if (!isDragging) mainPanel.classList.add('hidden-ui');
            }
        });

        // ================= 2. HUD È¢ëË∞±ÂèØËßÜÂåñ =================
        const hudCanvas = document.getElementById('hud-spectrum');
        const hudCtx = hudCanvas.getContext('2d');
        const gradientHud = hudCtx.createLinearGradient(0, 100, 0, 0);
        gradientHud.addColorStop(0, '#ffaa00'); 
        gradientHud.addColorStop(0.4, '#ffdd00');
        gradientHud.addColorStop(1, '#ffffff'); 

        function drawHud(time) {
            const w = hudCanvas.width; const h = hudCanvas.height;
            hudCtx.clearRect(0, 0, w, h);
            let displayData = [];
            if (isPlaying && analyser) displayData = dataArray.slice(0, 64); 
            else {
                for(let i=0; i<64; i++) displayData[i] = (Math.sin(i * 0.2 + time * 3.0) * Math.cos(i * 0.1 - time) * 0.5 + 0.5) * 60 + 10; 
            }
            const barWidth = (w / displayData.length) * 0.6;
            const gap = (w / displayData.length) * 0.4;
            hudCtx.fillStyle = gradientHud;
            hudCtx.shadowBlur = 10; hudCtx.shadowColor = 'rgba(255, 200, 0, 0.5)';

            for (let i = 0; i < displayData.length; i++) {
                const value = displayData[i];
                const percent = value / 255;
                const barHeight = percent * h * 0.8;
                const x = i * (barWidth + gap) + 10;
                const y = h - barHeight;
                hudCtx.fillRect(x, y, barWidth, barHeight);
                if (value > 10) {
                    hudCtx.fillStyle = '#fff';
                    hudCtx.fillRect(x, y - 3, barWidth, 2);
                    hudCtx.fillStyle = gradientHud;
                }
            }
            hudCtx.shadowBlur = 0; 
        }

        // ================= 3. Three.js Âú∫ÊôØÊûÑÂª∫ =================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#000510'); 
        scene.fog = new THREE.FogExp2(0x000510, 0.015); 

        const camera = new THREE.PerspectiveCamera(60, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
        camera.position.set(0, 12, 30); 
        camera.lookAt(0, 2, -50);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        viewport.appendChild(renderer.domElement);

        // Sun
        const sunGeo = new THREE.CircleGeometry(8, 64);
        const sunMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, color1: { value: new THREE.Color("#ffaa00") }, color2: { value: new THREE.Color("#ff0055") } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                uniform float uTime; uniform vec3 color1; uniform vec3 color2; varying vec2 vUv;
                void main() {
                    vec3 color = mix(color1, color2, vUv.y);
                    float stripe = sin(vUv.y * 200.0 - uTime * 0.5); 
                    float cut = step(0.5, vUv.y) + step(stripe, 0.8); 
                    float y = vUv.y; float alpha = 1.0;
                    if(y < 0.55) { float thickness = 0.5 - y * 0.6; if (sin(y * 80.0) < thickness) alpha = 0.0; }
                    if (alpha < 0.1) discard; gl_FragColor = vec4(color, 1.0);
                }
            `,
            transparent: true
        });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        sun.position.set(0, -5, -120);
        scene.add(sun);

        // ================= ‰ºòÂåñÂêéÁöÑÊòüÊòüÁ≥ªÁªü (Star System V2) =================
        const starGeo = new THREE.BufferGeometry();
        const starCount = 15000; 
        const starPos = []; 
        const starData = []; // Â≠òÊîæ: [Âü∫Á°ÄÂ§ßÂ∞è, Èó™ÁÉÅÈÄüÂ∫¶, Èó™ÁÉÅÂÅèÁßª]
        const starColors = [];

        const color1 = new THREE.Color('#ffffff'); // Á∫ØÁôΩ
        const color2 = new THREE.Color('#00ffff'); // ËµõÂçöÈùí
        const color3 = new THREE.Color('#ffcc00'); // ËæâÁÖåÈáë

        for(let i=0; i<starCount; i++) {
            // ‰ΩçÁΩÆÂàÜÂ∏É
            const x = (Math.random() - 0.5) * 1600;
            const y = Math.random() * 280 - 5; 
            const z = -Math.random() * 400 - 60;
            starPos.push(x, y, z);
            
            // È¢úËâ≤ÈöèÊú∫
            const rand = Math.random();
            let c = color1;
            if(rand > 0.9) c = color3; 
            else if(rand > 0.7) c = color2; 
            
            starColors.push(c.r, c.g, c.b);

            // Â§ßÂ∞è‰∏éÈó™ÁÉÅÂèÇÊï∞
            const sizeBase = Math.random() * 2.0 + 1.0; 
            const isMegaStar = Math.random() < 0.05; 
            
            starData.push(
                isMegaStar ? sizeBase * 3.5 : sizeBase, 
                Math.random() * 3.0 + 0.5, 
                Math.random() * 100.0
            );
        }
        
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        starGeo.setAttribute('aData', new THREE.Float32BufferAttribute(starData, 3));

        const starMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 } },
            vertexShader: `
                uniform float uTime; 
                attribute vec3 aData; // x: size, y: speed, z: offset
                attribute vec3 color;
                varying vec3 vColor;
                varying float vAlpha;
                
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // Ë∑ùÁ¶ªÈÄèËßÜ‰ºòÂåñ
                    float distSize = aData.x * (300.0 / -mvPosition.z);
                    gl_PointSize = clamp(distSize, 2.0, 15.0);

                    float blink = sin(uTime * aData.y + aData.z);
                    float twinkle = pow(0.5 + 0.5 * blink, 3.0); 
                    vAlpha = 0.4 + 0.6 * twinkle; 
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;
                
                void main() {
                    vec2 uv = gl_PointCoord.xy - 0.5; 
                    float d = length(uv); 
                    if (d > 0.5) discard; 

                    // ÂÖâÊôïÊ†∏ÂøÉ‰ºòÂåñ
                    float glow = 1.0 - (d * 2.0);
                    glow = pow(glow, 1.5); 
                    vec3 finalColor = mix(vColor, vec3(1.0), glow * 0.5);

                    gl_FragColor = vec4(finalColor, vAlpha * glow);
                }
            `,
            transparent: true, 
            blending: THREE.AdditiveBlending, 
            depthWrite: false
        });

        const starSystem = new THREE.Points(starGeo, starMat);
        scene.add(starSystem);

        // Terrain Particles
        const geometry = new THREE.BufferGeometry();
        const positions = []; const randoms = []; const lineIndices = []; 
        const pointsPerLine = Math.floor(CONFIG.particleCount / CONFIG.lineCount);
        for (let i = 0; i < CONFIG.lineCount; i++) {
            const z = (i / CONFIG.lineCount - 0.5) * CONFIG.rangeZ;
            for (let j = 0; j < pointsPerLine; j++) {
                const x = (j / pointsPerLine - 0.5) * CONFIG.rangeX;
                positions.push(x, 0, z);
                randoms.push(Math.random(), Math.random(), Math.random());
                lineIndices.push(i / CONFIG.lineCount);
            }
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 3));
        geometry.setAttribute('aLine', new THREE.Float32BufferAttribute(lineIndices, 1));

        const vertexShader = `
            uniform float uTime; uniform float uScale; uniform float uSpeed;
            attribute vec3 aRandom; attribute float aLine;
            varying float vType; varying float vHeight; varying float vIntensity; varying float vDist;
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
            void main() {
                vec3 pos = position;
                float flyOffset = uTime * uSpeed; 
                float noiseZ = pos.z - flyOffset;
                float riverCurve = sin(noiseZ * 0.05) * 15.0 + sin(noiseZ * 0.2) * 5.0;
                float distToRiver = abs(pos.x - riverCurve);
                float height = 0.0; float pointSize = 0.0;
                if (distToRiver < 5.0) {
                    vType = 0.0; float flow = snoise(vec2(pos.x * 0.5, noiseZ * 0.2 - uTime * 2.0));
                    height = flow * 0.8; pointSize = 3.5 * (1.0 - distToRiver / 6.0); 
                    vIntensity = 1.0 + 0.5 * sin(uTime * 5.0 + aRandom.x * 20.0) + uScale;
                } else if (distToRiver < 12.0) { vType = 2.0; pointSize = 0.0; }
                else {
                    vType = 1.0; float mDist = distToRiver - 12.0;
                    float n1 = snoise(vec2(pos.x * 0.04, noiseZ * 0.04)); float n2 = snoise(vec2(pos.x * 0.1, noiseZ * 0.1));   
                    height = (abs(n1) * 6.0 + n2 * 2.0) * (mDist * 0.035); height = max(height, -2.0); 
                    
                    height *= (0.5 + uScale * 0.25); 
                    
                    pointSize = 1.8 + height * 0.05;
                    float linePattern = sin(noiseZ * 0.5); 
                    if (linePattern > 0.9) { pointSize *= 1.2; vIntensity = 2.0; } else { vIntensity = 1.2; }
                }
                pos.y = height; vHeight = height;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_Position = projectionMatrix * mvPosition; vDist = -mvPosition.z;
                gl_PointSize = pointSize * (50.0 / vDist);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColorRiver; uniform vec3 uColorMtBase; uniform vec3 uColorMtTop;
            varying float vType; varying float vHeight; varying float vIntensity; varying float vDist;
            void main() {
                if (vType > 1.5 && vType < 2.5) discard;
                vec2 uv = gl_PointCoord.xy - 0.5; float d = length(uv); if (d > 0.5) discard;
                float alpha = 1.0 - smoothstep(0.1, 0.5, d); vec3 color = vec3(0.0);
                if (vType < 0.5) { color = uColorRiver; color += vec3(0.4); } 
                else {
                    float hFactor = clamp(vHeight / 25.0, 0.0, 1.0); 
                    vec3 baseMix = mix(uColorMtBase, uColorMtTop, pow(hFactor, 0.8));
                    color = baseMix * vIntensity * 1.2; 
                    if (hFactor > 0.6) color += vec3(0.2);
                }
                float nearFade = smoothstep(5.0, 50.0, vDist); 
                float farFade = 1.0 - smoothstep(140.0, 200.0, vDist);
                alpha *= nearFade * farFade;
                gl_FragColor = vec4(color, alpha);
            }
        `;

        const uniforms = {
            uTime: { value: 0 }, uScale: { value: 0.0 }, uSpeed: { value: CONFIG.speed },
            uColorRiver: { value: CONFIG.colorRiver }, uColorMtBase: { value: CONFIG.colorMtBase }, uColorMtTop: { value: CONFIG.colorMtTop }
        };

        const material = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
        const particleSystem = new THREE.Points(geometry, material);
        particleSystem.position.y = -25.0; 
        particleSystem.position.z = -20.0; 
        scene.add(particleSystem);

        // ================= 4. ÊéßÂà∂ÈÄªËæë (ÊâãÂäø + Ëß¶Êéß) =================
        let isDragging = false;
        let lastTouchX = 0;
        let cameraXOffset = 0; 
        let currentCameraX = 0; 
        const MAX_OFFSET = 25; 
        const SENSITIVITY = 0.1; 

        let smoothedHandX = 0.5; 
        let isHandActive = false;
        let lastHandActiveTime = 0;

        const touchIndicator = document.getElementById('touch-indicator');
        const camBtn = document.getElementById('cam-btn');
        const webcamPreview = document.getElementById('webcam-preview');
        const previewCtx = webcamPreview.getContext('2d');

        function updateIndicator(x, y, active) {} 

        function onStart(clientX, clientY) {
            const rect = viewport.getBoundingClientRect();
            if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) return;
            const el = document.elementFromPoint(clientX, clientY);
            if (el && el.closest('.panel') && !el.closest('.panel').classList.contains('hidden-ui')) return;
            if (isHandActive) return;
            isDragging = true; lastTouchX = clientX; 
        }

        function onMove(clientX, clientY) {
            if (!isDragging) return;
            if (isHandActive) { isDragging = false; return; }
            const deltaX = clientX - lastTouchX;
            cameraXOffset -= deltaX * SENSITIVITY;
            cameraXOffset = Math.max(-MAX_OFFSET, Math.min(MAX_OFFSET, cameraXOffset));
            lastTouchX = clientX; 
        }
        function onEnd() { isDragging = false; }

        window.addEventListener('mousedown', e => onStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', onEnd);
        window.addEventListener('touchstart', e => onStart(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
        window.addEventListener('touchmove', e => onMove(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
        window.addEventListener('touchend', onEnd);

        // ================= 5. MediaPipe ÊâãÂäøËØÜÂà´Á≥ªÁªü =================
        const videoElement = document.getElementById('input-video');
        let cameraUtils = null;

        function onResults(results) {
            webcamPreview.width = videoElement.videoWidth;
            webcamPreview.height = videoElement.videoHeight;
            previewCtx.save();
            previewCtx.clearRect(0, 0, webcamPreview.width, webcamPreview.height);
            previewCtx.translate(webcamPreview.width, 0);
            previewCtx.scale(-1, 1);
            previewCtx.drawImage(results.image, 0, 0, webcamPreview.width, webcamPreview.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2});
                drawLandmarks(previewCtx, landmarks, {color: '#ffcc00', lineWidth: 1, radius: 3});

                const rawX = landmarks[9].x; 
                smoothedHandX = smoothedHandX * 0.92 + (1.0 - rawX) * 0.08; 
                const targetOffset = (smoothedHandX - 0.5) * 60; 
                cameraXOffset = Math.max(-MAX_OFFSET, Math.min(MAX_OFFSET, targetOffset));

                isHandActive = true;
                lastHandActiveTime = Date.now();
                statusText.innerText = "ÊâãÂäøÊéßÂà∂‰∏≠...";
            } else {
                if (Date.now() - lastHandActiveTime > 1000) {
                    isHandActive = false;
                    if(webcamPreview.classList.contains('active')) statusText.innerText = "Á≠âÂæÖÊâãÂäøÊåá‰ª§...";
                }
            }
            previewCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        camBtn.addEventListener('click', () => {
            statusText.innerText = "Ê≠£Âú®ÂêØÂä®ÊëÑÂÉèÂ§¥...";
            camBtn.disabled = true;
            cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240
            });
            cameraUtils.start().then(() => {
                statusText.innerText = "ÊëÑÂÉèÂ§¥Â∑≤ÂêØÂä® - ËØ∑‰∏æÊâã";
              // webcamPreview.style.display = 'block';
                webcamPreview.classList.add('active');
                camBtn.innerText = "üì∑ ÊâãÂäøÁ≥ªÁªüËøêË°å‰∏≠";
                setTimeout(() => { if(!isPlaying) mainPanel.classList.add('hidden-ui'); }, 3000);
            }).catch(err => { console.error(err); statusText.innerText = "ÊëÑÂÉèÂ§¥ÂêØÂä®Â§±Ë¥•"; camBtn.disabled = false; });
        });

        // ================= 6. Âä®ÁîªÂæ™ÁéØ =================
        const clock = new THREE.Clock();
        let targetScale = 0.1; let currentScale = 0.1;

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            if (isPlaying && analyser) {
                analyser.getByteFrequencyData(dataArray);
                const audioScale = getBassSignal();
                const breathing = 0.05 + Math.sin(t * 1.0) * 0.2;
                targetScale = Math.max(audioScale, breathing);
            } else {
                targetScale = 0.1 + Math.sin(t * 1.2) * 0.08; 
            }

            drawHud(t);
            let ease = (targetScale > currentScale) ? 0.3 : 0.08; 
            currentScale += (targetScale - currentScale) * ease;
            currentCameraX += (cameraXOffset - currentCameraX) * 0.05;

            camera.position.x = currentCameraX;
            camera.position.y = 12 + Math.sin(t * 0.5) * 0.5;
            camera.rotation.z = (Math.sin(t * 0.2) * 0.02);

            uniforms.uTime.value = t;
            uniforms.uScale.value = currentScale;
            sunMat.uniforms.uTime.value = t;
            starMat.uniforms.uTime.value = t;

            renderer.render(scene, camera);
        }
        animate();

        document.getElementById('fs-btn').addEventListener('click', () => {
             if (!document.fullscreenElement) document.documentElement.requestFullscreen();
             else document.exitFullscreen();
        });

        window.addEventListener('resize', () => {
            const w = viewport.clientWidth;
            const h = viewport.clientHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        });
    </script>
</body>
</html>

    
